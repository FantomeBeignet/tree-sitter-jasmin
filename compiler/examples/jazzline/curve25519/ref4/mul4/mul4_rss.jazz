require "reduce4.jazz"

abstract predicate bool eqmod(int, int, tuple);
abstract predicate tuple single(int);
abstract predicate int b2i(bool);
abstract predicate int u64i(u64);
abstract predicate int pow(int, int);

inline fn __mul4_rss(stack u64[4] xa ya) -> reg u64[4]
 ensures #[prover=cas] {
  eqmod (
     \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(result.0[ii])),
     \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(xa[ii])) * \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(ya[ii])),
     single((pow(2,255)) - 19)
    )
  }

{
  reg u64[8] z;
  reg u64[4] r x y;
  reg u64 h l hprev;
  reg bool cf;
  inline int i j;

  for i = 0 to 8 { z[i] = #MOV(0); }

  x[0] = xa[0];
  for j = 0 to 4 {
    y[j] = ya[j];
    h, l = y[j] * x[0];
    if (j == 0) {
      z[0] = l;
      z[1] = h;
    } else {
      cf, z[j] += l;
      cf, z[j + 1] += h + cf;
      #[kind=Assert, prover=smt] assert (!cf);
      #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
    }
  }

  for i = 1 to 4 {
    x[i] = xa[i];
    for j = 0 to 4 {
      y[j] = ya[j];
      h, l = y[j] * x[i];
      cf, z[i+j] += l;
      if (j == 0) {
        hprev = #MOV(0);
        cf, hprev += h + cf;
        #[kind=Assert, prover=smt] assert (!cf);
        #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
      } else {
        cf, h += 0 + cf;
        #[kind=Assert, prover=smt] assert (!cf);
        #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
        cf, z[i+j] += hprev;
        if (1 <= j && j < 4 - 1) {
          hprev = #MOV(0);
          cf, hprev += h + cf;
          #[kind=Assert, prover=smt] assert (!cf);
          #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
        } else { /* j = 4 */
          cf, z[i + j + 1] += h + cf;
          #[kind=Assert, prover=smt] assert (!cf);
          #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
        }
      }
    }
  }

  r = __reduce4(z);

  return r;
}
