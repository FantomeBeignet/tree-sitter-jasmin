abstract predicate bool eqmod(int, int, tuple);
abstract predicate tuple single(int);
abstract predicate int b2i(bool);
abstract predicate int u64i(u64);
abstract predicate int pow(int, int);

inline fn __reduce4(reg u64[8] z) -> reg u64[4]
     ensures #[prover=cas] {
  eqmod (
     \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(result.0[ii])),
     \sum (ii \in 0:8) (pow(2, 64*ii)*u64i(z[ii])),
     single((pow(2,255)) - 19)
    )
  }

{
  reg u64 z8 r0 r38 rax h l, dc;
  reg u64[4] r;
  reg bool cf;
  inline int i;

   r38 = 38;

	rax = z[4];
	h, l = rax * r38;
	r[0] = l;
	r[1] = h;

	rax = z[5];
	h, l = rax * r38;
	cf, r[1] += l;


  r[2] = #MOV(0);
	rax = z[6];
	cf, r[2] += h + cf;

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);

	h, l = rax * r38;
  cf, r[2] += l;

	r[3] = #MOV(0);
	rax = z[7];
	cf, r[3] += h + cf;
  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);


	h, l = rax * r38;
	cf, r[3] += l;

	z8 = #MOV(0);
	cf, z8  += h + cf;
  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);


	cf, r[0] += z[0];

    for i = 1 to 4 {
  	  cf, r[i] += z[i] + cf;
	}

	cf, z8 += 0 + cf;
  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);


	dc, z8 *= 38;
  #[kind=Assert, prover=smt] assert (dc == 0);
  #[kind=Assume, prover=cas] assert (dc == 0);

    r0 = #MOV(0);
    cf, r[0] += z8;

    for i = 1 to 4 {
        cf, r[i] += r0 + cf;
    }

	cf, r0 += r0 + cf;
  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);

	dc, r0 *= 38;
  #[kind=Assert, prover=smt] assert (dc == 0);
  #[kind=Assume, prover=cas] assert (dc == 0);

  cf, r[0] += r0;
  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);

  return r;
}
