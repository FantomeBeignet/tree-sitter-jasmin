inline fn rotate_offset_BL(reg u32 md_size mac_start scan_start) -> reg u32 {
  reg u32 rotate_offset;
  rotate_offset = mac_start;
  rotate_offset -= scan_start;
  rotate_offset = rotate_offset % md_size;
  return rotate_offset;
}

inline fn rotate_offset_TV(reg u32 md_size mac_start scan_start) -> reg u32 {
  reg u32 div_spoiler;
  reg u32 rotate_offset;
  div_spoiler = md_size;
  div_spoiler <<= 23;
  rotate_offset = mac_start;
  rotate_offset -= scan_start;
  rotate_offset += div_spoiler;
  rotate_offset = rotate_offset % md_size;
  return rotate_offset;
}

inline fn opp_mod(reg u32 rotate_offset md_size) -> reg u32 {
  reg u32 temp, zero;

  zero = 0;
  temp = md_size;
  temp -= rotate_offset;
  rotate_offset = temp;
  rotate_offset = zero if rotate_offset == md_size;
  return rotate_offset;
}

inline fn rotate_mac_BL(reg u32 md_size rotate_offset, reg u64 out, stack u8[64] rotated_mac) {
  reg u64 i, j;
  reg u32 old, new, zero, temp;

  zero = 0;
  rotate_offset = opp_mod(rotate_offset, md_size);
  i = 0;
  while(i < md_size) {
     j = 0;
    while(j < md_size) {
      old = (32u)(u8)[out + j];
      new = (32u)rotated_mac[(int) i];
      new = old if j != rotate_offset;
      (u8)[out + j] = new;
      j += 1;
    }
    rotate_offset += 1;
    rotate_offset = zero if md_size <= rotate_offset;
    i += 1;
  }
}

inline fn rotate_mac_CL(reg u32 md_size rotate_offset, reg u64 out rotated_mac) {
  reg u8 new;
  reg u64 i, zero, ro;

  zero = 0;
  ro = (64u) rotate_offset;
  i = 0;
  while (i < md_size) {
    new = (u8)[rotated_mac + ro];
    (u8)[out + i] = new;
    ro += 1;
    ro = zero if md_size <= ro;
    i += 1;
  }
}

inline fn rotate_mac_CL32(reg u32 md_size rotate_offset, reg u64 out rotated_mac) {
  reg u64 i, zero, ro, ro_and, ro_or, new, new_or ;

  zero = 0;
  ro = (64u) rotate_offset;
  i = 0;
  while (i < md_size) {
    ro_and = ro; ro_and &= !(64u)32;
    new = (64u)(u8)[rotated_mac + ro_and];
    ro_or = ro; ro_or |= (64u)32;
    new_or = (64u)(u8)[rotated_mac + ro_or];
    new = new_or if ro == ro_or;
    (u8)[out + i] = new;
    ro += 1;
    ro = zero if md_size <= ro;
    i += 1;
  }
}

inline fn init_scan_start(reg u64 rec, reg u32 orig_len, reg u32 md_size) -> reg u64, reg u32, reg u32, reg u32 {
  reg u32 mac_start, mac_end, scan_start, temp;
  reg u64 zero, data;
  zero = 0;
  data = (u64)[rec + 16];
  mac_end = (u32)[rec + 4];
  mac_start = mac_end;
  mac_start -= md_size;
  scan_start = 0;
  temp = md_size;
  temp += 256;
  if (orig_len > temp) {
    scan_start = orig_len;
    scan_start -= temp;
  }
  return data, scan_start, mac_start, mac_end;
}

inline fn init_rotated_mac_stk(reg u64 data, reg u32 scan_start, reg u32 mac_start, reg u32 mac_end, reg u32 orig_len, reg u32 md_size) -> stack u8[64] {
  stack u8[64] rotated_mac;
  reg u32 old, new;
  reg u64 i, j, zero;

  i = 0;
  while (i < 64) {
    rotated_mac[(int)i] = 0;
    i += 1;
  }

  zero = 0;
  i = (64u)scan_start;
  j = 0;
  while(i < orig_len) {
    new = (32u)(u8)[data + (int)i];
    old = (32u)rotated_mac[(int)j];
    new = old if i < mac_start;
    new = old if i >= mac_end;
    rotated_mac[(int)j] = new;
    j += 1;
    j = zero if md_size <= j;
    i += 1;
  }
  return rotated_mac;
}

inline fn init_rotated_mac_mem(reg u64 rotated_mac, reg u64 data, reg u32 scan_start, reg u32 mac_start, reg u32 mac_end, reg u32 orig_len, reg u32 md_size) {
  reg u32 old, new;
  reg u64 i, j, zero;

  i = 0;
  while (i < 64) {
    (u8)[rotated_mac + i] = 0;
    i += 1;
  }
  zero = 0;
  i = (64u) scan_start;
  j = 0;
  while(i < orig_len) {
    new = (32u)(u8)[data + (int)i];
    old = (32u)(u8)[rotated_mac + j];
    new = old if i < mac_start;
    new = old if i >= mac_end;
    (u8)[rotated_mac + j] = new;
    j += 1;
    j = zero if md_size <= j;
    i += 1;
  }
}

export
fn
ssl3_cbc_copy_mac_BL_BL(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,
    reg u32 md_size
  )
{
  stack u8[64] rotated_mac;    // char array
  reg u32 mac_start, mac_end, scan_start, rotate_offset;
  reg u64 data;

  data, scan_start, mac_start, mac_end = init_scan_start(rec, orig_len, md_size);
  rotated_mac = init_rotated_mac_stk(data, scan_start, mac_start, mac_end, orig_len, md_size);
  rotate_offset = rotate_offset_BL(md_size, mac_start, scan_start);
  rotate_mac_BL(md_size, rotate_offset, out, rotated_mac);
}

export
fn
ssl3_cbc_copy_mac_BL_CL(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,
    reg u32 md_size,
    reg u64 rotated_mac
  )
{
  // assuming CBC_MAC_ROTATE_IN_PLACE is defined
  reg u32 mac_start, mac_end, scan_start;
  reg u64 i, j, zero, data;
  reg u32 rotate_offset, old, new, temp;

  data, scan_start, mac_start, mac_end = init_scan_start(rec, orig_len, md_size);
  init_rotated_mac_mem(rotated_mac, data, scan_start, mac_start, mac_end, orig_len, md_size);
  rotate_offset = rotate_offset_BL(md_size, mac_start, scan_start);
  rotate_mac_CL(md_size, rotate_offset, out, rotated_mac);
}

export
fn
ssl3_cbc_copy_mac_TV_BL(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,
    reg u32 md_size
  )
{
  stack u8[64] rotated_mac;    // char array
  reg u32 mac_start, mac_end, scan_start, rotate_offset;
  reg u64 data;

  data, scan_start, mac_start, mac_end = init_scan_start(rec, orig_len, md_size);
  rotated_mac = init_rotated_mac_stk(data, scan_start, mac_start, mac_end, orig_len, md_size);
  rotate_offset = rotate_offset_TV(md_size, mac_start, scan_start);
  rotate_mac_BL(md_size, rotate_offset, out, rotated_mac);
}

export
fn
ssl3_cbc_copy_mac_TV_CL(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,
    reg u32 md_size,
    reg u64 rotated_mac
  )
{
  // assuming CBC_MAC_ROTATE_IN_PLACE is defined
  reg u32 mac_start, mac_end, scan_start;
  reg u64 i, j, zero, data;
  reg u32 rotate_offset, old, new, temp;

  data, scan_start, mac_start, mac_end = init_scan_start(rec, orig_len, md_size);
  init_rotated_mac_mem(rotated_mac, data, scan_start, mac_start, mac_end, orig_len, md_size);
  rotate_offset = rotate_offset_TV(md_size, mac_start, scan_start);
  rotate_mac_CL(md_size, rotate_offset, out, rotated_mac);
}

export
fn
ssl3_cbc_copy_mac_BL_CL32(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,
    reg u32 md_size,
    reg u64 rotated_mac
  )
{
  // assuming CBC_MAC_ROTATE_IN_PLACE is defined
  reg u32 mac_start, mac_end, scan_start;
  reg u64 i, j, zero, data;
  reg u32 rotate_offset, old, new, temp;

  data, scan_start, mac_start, mac_end = init_scan_start(rec, orig_len, md_size);
  init_rotated_mac_mem(rotated_mac, data, scan_start, mac_start, mac_end, orig_len, md_size);
  rotate_offset = rotate_offset_BL(md_size, mac_start, scan_start);
  rotate_mac_CL32(md_size, rotate_offset, out, rotated_mac);
}

export
fn
ssl3_cbc_copy_mac_TV_CL32(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,
    reg u32 md_size,
    reg u64 rotated_mac
  )
{
  // assuming CBC_MAC_ROTATE_IN_PLACE is defined
  reg u32 mac_start, mac_end, scan_start;
  reg u64 i, j, zero, data;
  reg u32 rotate_offset, old, new, temp;

  data, scan_start, mac_start, mac_end = init_scan_start(rec, orig_len, md_size);
  init_rotated_mac_mem(rotated_mac, data, scan_start, mac_start, mac_end, orig_len, md_size);
  rotate_offset = rotate_offset_TV(md_size, mac_start, scan_start);
  rotate_mac_CL32(md_size, rotate_offset, out, rotated_mac);
}
