abstract predicate bool eqmod(int, int, tuple);
abstract predicate tuple single(int);
abstract predicate int pow(int, int);

inline fn __add4_rrs(reg u64[4] f, stack u64[4] g) -> reg u64[4]
ensures #[prover=cas] {eqmod(pow(2,64), 0 ,single((int)(2^255 - 19)))}
{
  inline int i;
  reg bool cf;
  reg u64[4] h;
  reg u64 z;


  h = #copy(f);

  cf, h[0] += g[0];
  for i=1 to 4
  { cf, h[i] += g[i] + cf; }

  _, z -= z - cf;
  z &= 38;

  cf, h[0] += z;
  for i=1 to 4
  { cf, h[i] += 0 + cf; }

  _, z -= z - cf;
  z &= 38;
  h[0] += z;

  return h;
}

inline fn add4(reg u64[4] f, stack u64[4] g) -> reg u64[4]
{
  inline int i;
  reg bool cf;
  reg u64[4] h;
  reg u64 z;

  ?{}, z = #set0();

  h = #copy(f);

  cf, h[0] += g[0];
  for i=1 to 4
  { cf, h[i] += g[i] + cf; }

  _, z -= z - cf;
  z &= 38;

//  assert (z == (cf ? 38 : 0));


  cf, h[0] += z;
  for i=1 to 4
  { cf, h[i] += 0 + cf; }

  _, z -= z - cf;
  z &= 38;

//  assert (z == (cf ? 38 : 0));
  cf, h[0] += z;
//  assert (!cf);

  return h;
}
