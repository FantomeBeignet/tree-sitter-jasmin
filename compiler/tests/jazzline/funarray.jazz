fn fill (reg u64[4] t) -> reg u64[4]
requires #[prover=smt] { 0 == t[0] }
ensures #[prover=smt] { result.0[0] == t[0] }
{
  inline int i;
  for i = 0 to 4 {
    t[i] = i;
  }
  return t;
}

fn f () -> reg u64 {
  reg u64[4] t;
  /* Remark the array_copy introduced after inlining does not make sens ...
     A solution will be to do a "After variable renaming to remove copies"
  */
  t = fill(t);

  reg u64 r;
  inline int i;

  r = 0;
  for i = 0 to 4 {
    r += t[i];
  }
  return r;

}