abstract type word_list;
abstract predicate word_list word_nil ();
abstract predicate word_list word_cons (u64, word_list);

abstract predicate int limbs (int, word_list);

abstract predicate bool eqmod (int,int,int);

abstract predicate int mon(int, int, int) ;

param int KYBER_N = 3;


u16[128] jzetas = {2285, 2571, 2970, 1812, 1493, 1422, 287, 202, 3158, 622, 1577, 182, 962, 2127, 1855, 1468, 
                  573, 2004, 264, 383, 2500, 1458, 1727, 3199, 2648, 1017, 732, 608, 1787, 411, 3124, 1758, 
                  1223, 652, 2777, 1015, 2036, 1491, 3047, 1785, 516, 3321, 3009, 2663, 1711, 2167, 126, 1469, 
                  2476, 3239, 3058, 830, 107, 1908, 3082, 2378, 2931, 961, 1821, 2604, 448, 2264, 677, 2054, 
                  2226, 430, 555, 843, 2078, 871, 1550, 105, 422, 587, 177, 3094, 3038, 2869, 1574, 1653, 
                  3083, 778, 1159, 3182, 2552, 1483, 2727, 1119, 1739, 644, 2457, 349, 418, 329, 3173, 3254, 
                  817, 1097, 603, 610, 1322, 2044, 1864, 384, 2114, 3193, 1218, 1994, 2455, 220, 2142, 1670, 
                  2144, 1799, 2051, 794, 1819, 2475, 2459, 478, 3221, 3021, 996, 991, 958, 1869, 1522, 1628};


fn _test2 (reg ptr u16 [KYBER_N] rp) -> (reg ptr u16 [KYBER_N])
{
  inline int j;
  for j = 0 to KYBER_N
  {
    rp[(int)j] = jzetas[(int)j];
  }
  return rp;
}

fn _test(#[test] reg u64 a, reg u64 b, reg ptr u16[KYBER_N] rp) -> (reg u64, reg ptr u16[KYBER_N], reg u64)
requires #[prover=cas] { a == 1 }
requires #[prover=cas] { a == 1 }
requires #[prover=smt] { a == 1 }
requires #[prover=smt] { a == 1 }
requires #[prover=smt] { rp[0] == 1 && rp[1] == 1 }
ensures #[prover=smt] { result.0 ==  a + b}
ensures #[prover=smt] { result.2 ==  a + b}
ensures #[prover=smt] { result.2 ==  a + 2}
ensures #[prover=smt] { rp[2] == 1 && result.1[2] == 1 &&   result.1[2] == rp[2] }
ensures #[prover=smt] { result.0 == 2}
ensures #[prover=cas] { mon(1, 10, 5) == mon(1,10,2) + mon(1,10,3) }
{
  reg u64 c;
  reg u64 d;
  reg u64 e;

 #[kind=Assert, prover=smt] assert (rp[0] == 1);


  a = a + 1;
  #[tran=default] c = a + b;
  rp = _test2(rp);
  #[tran=default]c = c + d;
  c = c + e;
  rp[2] = rp[2] + 1;

/*  #[kind=Assert, prover=cas] assert (eqmod ( limbs (64, word_cons ( a, word_nil () )) + limbs (64, word_cons ( b, word_nil () )),
                                               limbs (64, word_cons ( c, word_nil ())), 64));*/

  return (c,rp,a);
}
